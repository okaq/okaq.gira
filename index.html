<!DOCTYPE html>
<html lang="en">
    <head id="zeta">
        <title>okaq</title>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=1920,height=1080,initial-scale=1" />
        <meta name="source" content="https://github.com/okaq/okaq.gira" />
        <meta name="author" content="AQ<aq@okaq.com>" />
        <meta name="date" content="2014-06-14" />
        <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAMklEQVR4nGIJWf6fgZaAiaamj1owasGoBaMWjFowasGoBaMWjFowasGoBVQEgAAAAP//qJgCPYgbKBUAAAAASUVORK5CYII=" />
        <style type="text/css">
            html,body{width:1920px;height:1080px;margin:0px;border:0px;padding:0px;background-color:rgba(0,0,0,0);}
        </style>
        <script type="text/javascript">
            // ok
        console.log("okaq gira bibi go");
        // async load
        (function() {
         var a = {
            "load": function(e) {
                g.init();
            }
         }
         window.addEventListener("load", a.load, false);
         })();
// game
var g = {
    "init": function() {
        c.init();
        d.init();
        var start = window.performance.now();
        t.init();
        r.quad(t.root);
        var delta = window.performance.now() - start;
        console.log("total render time: " + delta + "ms.");
    }
}
// dom
var d = {
    "init": function() {
        d.w = 1920;
        d.w2 = (d.w / 2.0) >>> 0;
        d.w4 = (d.w / 4.0) >>> 0;
        d.h = 1080;
        d.h2 = (d.h / 2.0) >>> 0;
        d.h4 = (d.h / 4.0) >>> 0;
        d.alpha = document.getElementById("alpha");
        d.beta = {};
        d.beta.can = document.createElement("canvas");
        d.alpha.appendChild(d.beta.can);
        d.beta.con = d.beta.can.getContext("2d");
        d.beta.can.width = d.w;
        d.beta.can.height = d.h;
        d.beta.can.style.position = "absolute";
        d.beta.can.style.left = "0px";
        d.beta.can.style.top = "0px";
        window.addEventListener("keydown", d.key, false);
        // d.gamma - 1024x1024 centered canvas
    },
    "key": function(e) {
        // console.log(e);
    }
}
// render
var r = {
    "quad": function(n0) {
        if (n0.c0.length == 0) {
            // rect
            c.shuf();
            d.beta.con.fillStyle = c.cssr();
            d.beta.con.fillRect(n0.r0.x0, n0.r0.y0, n0.r0.w0, n0.r0.h0);
            // inv
            c.shuf();
            d.beta.con.fillStyle = c.cssr();
            var min = (n0.r0.w0 > n0.r0.h0) ? n0.r0.h0 : n0.r0.w0;
            var s0 = (min / n0.r0.inv.n0) >>> 0;
            var m0 = (s0 / 16) >>> 0;
            var s1 = (s0 - (2 * m0)) >>> 0;
            var s2 = (s0 * n0.r0.inv.n0) >>> 0;
            var mx = ((n0.r0.w0 - s2) / 2) >>> 0;
            var my = ((n0.r0.h0 - s2) / 2) >>> 0;
            // rotation
            d.beta.con.save();
            var x2 = (n0.r0.x0 + (n0.r0.w0 / 2.0)) >>> 0;
            var y2 = (n0.r0.y0 + (n0.r0.h0 / 2.0)) >>> 0;
            var f0 = Math.random();
            var a0 = 0;
            if (f0 >= 0.25 && f0 < 0.5) {
                a0 = Math.PI / 2.0;
            }
            if (f0 >= 0.5 && f0 < 0.75) {
                a0 = Math.PI;
            }
            if (f0 >= 0.75) {
                a0 = 3.0 * Math.PI / 2.0;
            }
            d.beta.con.translate(x2, y2);
            d.beta.con.rotate(a0);
            // draw inv
            for (var y = 0; y < n0.r0.inv.data.length; y++) {
                for (var x = 0; x < n0.r0.inv.data[y].length; x++) {
                    if (n0.r0.inv.data[y][x] == 0) continue;
                    // var x0 = ((x * s0) + n0.r0.x0) >>> 0;
                    // var x1 = (x0 + m0 + mx) >>> 0;
                    // var y0 = ((y * s0) + n0.r0.y0) >>> 0;
                    // var y1 = (y0 + m0 + my) >>> 0;
                    // d.beta.con.fillRect(x1, y1, s1, s1);
                    var x0 = ((x * s0) + m0 + mx) >>> 0;
                    var y0 = ((y * s0) + m0 + my) >>> 0;
                    d.beta.con.fillRect(x0, y0, s0, s0);
                }
            }
            d.beta.con.restore();
        } else {
            for (var i = 0; i < n0.c0.length; i++) {
                r.quad(n0.c0[i]);
            }
        }
    }
}
// tree
var t = {
    "init": function() {
        t.min = 64; // min subdivision length
        var r0 = new rect(0, 0, d.w, d.h);
        t.root = new node();
        t.root.r0 = r0;
        t.exp(t.root);
    },
    "exp": function(n0) {
        // expand input node
        // check min
        if (n0.r0.w0 <= t.min || n0.r0.h0 <= t.min) {
            return;
        }
        // stochastic factor
        var f0 = Math.random();
        if (f0 <= 0.25) {
            return;
        }
        // var i0 = 0;
        // subdivide quads
        var r1 = n0.r0.quad();
        for (var i = 0; i < r1.length; i++) {
            n0.c0[i] = new node();
            n0.c0[i].r0 = r1[i];
        }
        // expand child nodes
        for (var i = 0; i < n0.c0.length; i++) {
            t.exp(n0.c0[i]);
        }
    }
}
// node 
var node = function() {
    this.r0 = null; // rect
    this.c0 = []; // child
}
// rect
var rect = function(x0, y0, w0, h0) {
    this.x0 = x0;
    this.y0 = y0;
    this.w0 = w0;
    this.h0 = h0;
    this.c0 = c.comp();
    this.quad = function() {
        var r0 = [];
        // midpoint displacement
        var w1 = (this.w0 / 2.0) >>> 0;
        // displacement bug - 32-bit uint
        // w1 += ((1.0 * (Math.sin(Math.random() * Math.PI * 2.0))) >>> 0);
        w1 += ((Math.random() * 4.0) - 8.0);
        w1 = w1 >>> 0;
        var w2 = (this.w0 - w1) >>> 0;
        var h1 = (this.h0 / 2.0) >>> 0;
        h1 += ((Math.random() * 4.0) - 8.0);
        h1 = h1 >>> 0;
        var h2 = (this.h0 - h1) >>> 0;
        var x1 = (this.x0 + w1) >>> 0;
        var y1 = (this.y0 + h1) >>> 0;
        // subdivide into quads
        r0.push(new rect(this.x0, this.y0, w1, h1)); 
        r0.push(new rect(x1, this.y0, w2, h1));
        r0.push(new rect(this.x0, y1, w1, h2));
        r0.push(new rect(x1, y1, w2, h2));
        return r0;
        
    };
    // inv sets num only, renderer determines size, margin
    this.inv = new inv(5);
    var f0 = Math.random();
    if (f0 >= 0.9) {
        this.inv = new inv(9);
    }
    if (f0 <= 0.2) {
        this.inv = new inv(7);
    }
}
// inv
var inv = function(n0) {
    this.n0 = n0;
    // this.c0 = c.comp();
    this.data = [];
    this.n1 = (n0 / 2) >>> 0;
    for (var y = 0; y < this.n0; y++) {
        var a0 = [];
        for (var x = 0; x <= this.n1; x++) {
            var f0 = Math.random();
            if (f0 <= 0.5) {
                a0.push(1);
            } else {
                a0.push(0);
            }
        }
        for (var x = (this.n1 + 1); x < this.n0; x++) {
            a0.push(a0[this.n0 - x -1]);
        }
        this.data.push(a0);
    }
}
// color
var c = {
    "comp": function() {
        var c0 = [];
        for (var i = 0; i < 4; i++) {
            c0.push(c.rb(255));
        }
        return c0;
    },
    "init": function() {
        c.rgba = []; // type'd // instanceof
        c.hsla = [];
        c.shuf();
    },
    "shuf": function() {
        for (var i = 0; i < 4; i++) {
            c.rgba[i] = c.rb(255);
        }
        c.hsla[0] = c.rb(255);
        c.hsla[1] = c.rb(100);
        c.hsla[2] = c.rb(100);
        c.hsla[3] = c.rb(255);
    },
    "rb": function(n0) {
        return ((Math.random() * n0) >>> 0);
    },
    "cssr": function() {
        var s0 = "rgba(";
        for (var i = 0; i < 3; i++) {
            s0 += c.rgba[i].toString();
            s0 += ",";
        }
        s0 += (c.rgba[3] / 255.0).toString();
        s0 += ")";
        return s0;
    },
    "cssh": function() {
        var s0 = "hsla(";
        s0 += c.hsla[0].toString();
        s0 += ",";
        for (var i = 1; i < 3; i++) {
            s0 += c.hsla[i];
            s0 += "%,";
        }
        s0 += (c.hsla[3] / 255.0).toString();
        s0 += ")";
        return s0;
    }
}
        </script>
    </head>
    <body id="alpha">
    </body>
</html>
<!--
    
    tree subdivison of rects
    stochastically, down to min size
    each node contains, x0, y0, w0, h0, c0, inv0
    inv = n0, a0, m0, c0
    render - translate to center of rect, rotate (news), restore

-->
