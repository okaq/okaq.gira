<!DOCTYPE html>
<html lang="en">
    <head id="zeta">
        <title>okaq</title>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <meta name="viewport" content="width=1920,height=1080,initial-scale=1" />
        <meta name="source" content="https://github.com/okaq/okaq.gira" />
        <meta name="author" content="AQ<aq@okaq.com>" />
        <meta name="date" content="2014-06-14" />
        <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAMklEQVR4nGIJWf6fgZaAiaamj1owasGoBaMWjFowasGoBaMWjFowasGoBVQEgAAAAP//qJgCPYgbKBUAAAAASUVORK5CYII=" />
        <style type="text/css">
            html,body{width:1920px;height:1080px;margin:0px;border:0px;padding:0px;background-color:rgba(0,0,0,0);}
        </style>
        <script type="text/javascript">
            // ok
        console.log("okaq gira bibi go");
        // async load
        (function() {
         var a = {
            "load": function(e) {
                // console.log(e);
                g.init();
            }
         }
         window.addEventListener("load", a.load, false);
         })();
// game
var g = {
    "init": function() {
        c.init();
        d.init();
        // r.clear();
        var start = window.performance.now();
        /* 
        g.s0 = 9; // matrix : s0 x s0
        g.s1 = 54; // render side length
        g.s3 = d.w2 - ((g.s0 / 2) * g.s1); // offest x
        g.s4 = d.h2 - ((g.s0 / 2) * g.s1); // offset y
        g.s5 = 6; // margin
        // m.init(g.s0);
        m.inv(g.s0);
        console.log(m.data);
        r.grid(g.s3, g.s4, g.s1, g.s5);
        */
        t.init();
        console.log(t.root);
        r.quad(t.root);
        var delta = window.performance.now() - start;
        console.log("total render time: " + delta + "ms.");
    }
}
// dom
var d = {
    "init": function() {
        d.w = 1920;
        d.w2 = (d.w / 2.0) >>> 0;
        d.w4 = (d.w / 4.0) >>> 0;
        d.h = 1080;
        d.h2 = (d.h / 2.0) >>> 0;
        d.h4 = (d.h / 4.0) >>> 0;
        d.alpha = document.getElementById("alpha");
        d.beta = {};
        d.beta.can = document.createElement("canvas");
        d.alpha.appendChild(d.beta.can);
        d.beta.con = d.beta.can.getContext("2d");
        // console.log(d.alpha, d.beta);
        d.beta.can.width = d.w;
        d.beta.can.height = d.h;
        d.beta.can.style.position = "absolute";
        d.beta.can.style.left = "0px";
        d.beta.can.style.top = "0px";
        window.addEventListener("keydown", d.key, false);
    },
    "key": function(e) {
        console.log(e);
    }
}
// render
var r = {
    "clear": function() {
        d.beta.can.width = d.beta.can.width;
        var f0 = Math.random();
        if (f0 < 0.5) {
            d.beta.con.fillStyle = c.cssr();
        } else {
            d.beta.con.fillStyle = c.cssh();
        }
        // d.beta.con.fillRect(0,0,d.w,d.h);
        d.beta.con.fillRect(d.w4,d.h4,d.w2,d.h2);
    },
    "grid": function(x0, y0, s0, m0) {
        c.shuf();
        d.beta.con.fillStyle = c.cssr();
        for (var y = 0; y < m.data.length; y++) {
            for (var x = 0; x < m.data[y].length; x++) {
                if (m.data[y][x] == 0) continue;
                // c.shuf();
                // d.beta.con.fillStyle = c.cssr();
                var x1 = (x0 + (x * s0)) >>> 0;
                var y1 = (y0 + (y * s0)) >>> 0;
                d.beta.con.fillRect(x1 + m0, y1 + m0, s0 - (2 * m0), s0 - (2 * m0));
            }
        }
    },
    "quad": function(n0) {
        if (n0.c0.length == 0) {
            c.shuf();
            d.beta.con.fillStyle = c.cssr();
            d.beta.con.fillRect(n0.r0.x0, n0.r0.y0, n0.r0.w0, n0.r0.h0);
        } else {
            for (var i = 0; i < n0.c0.length; i++) {
                r.quad(n0.c0[i]);
            }
        }
    }
}
// matrix
var m = {
    "init": function(n0) {
        m.data = [];
        for (var i = 0; i < n0; i++) {
            var a0 = [];
            for (var j = 0; j < n0; j++) {
                var f0 = Math.random();
                if (f0 > 0.5) {
                    a0.push(0);
                } else {
                    a0.push(1);
                }
            }
            m.data.push(a0);
        }
    },
    "inv": function(n0) {
        m.data = [];
        var n1 = (n0 / 2) >>> 0;
        for (var y = 0; y < n0; y++) {
            var a0 = [];
            for (var x = 0; x <= n1; x++) {
                var f0 = Math.random();
                if (f0 > 0.5) {
                    a0.push(1);
                } else {
                    a0.push(0);
                }
            }
            for (var x = n1 + 1; x < n0; x++) {
                a0.push(a0[n0 - x - 1]);
            }
            m.data.push(a0);
        }
        /*
        for (var i = n1; i < n0; i++) {
            var i0 = n0 - i - 1;
            m.data.push(m.data[i0].slice(0));
        }
        */
    }
}
// tree
var t = {
    "init": function() {
        t.min = 256; // min subdivision length
        // t.data = [];
        var r0 = new rect(0, 0, d.w, d.h);
        // t.data.push(r0);
        // t.exp(t.data);
        t.root = new node();
        t.root.r0 = r0;
        t.exp(t.root);
    },
    "exp": function(n0) {
        // expand input node
        // check min
        if (n0.r0.w0 <= t.min || n0.r0.h0 <= t.min) {
            return;
        }
        // stochastic factor
        var f0 = Math.random();
        if (f0 <= 0.10) {
            return;
        }
        // var i0 = 0;
        // subdivide quads
        var r1 = n0.r0.quad();
        for (var i = 0; i < r1.length; i++) {
            n0.c0[i] = new node();
            n0.c0[i].r0 = r1[i];
        }
        // expand child nodes
        for (var i = 0; i < n0.c0.length; i++) {
            t.exp(n0.c0[i]);
        }
    }
}
// node 
var node = function() {
    this.r0 = null; // rect
    this.c0 = []; // child
}
// rect
var rect = function(x0, y0, w0, h0) {
    this.x0 = x0;
    this.y0 = y0;
    this.w0 = w0;
    this.h0 = h0;
    this.c0 = c.comp();
    this.quad = function() {
        if (this.w0 <= (2 * t.min) || this.h0 <= (2 * t.min)) {
            return [];
        }
        // subdivide into 4 quads
        var r0 = [];
        var x1 = ((Math.random() * this.w0) + this.x0) >>> 0;
        if ((x1 - this.x0) < t.min) x1 = t.min;
        var y1 = ((Math.random() * this.h0) + this.y0) >>> 0;
        if ((y1 - this.y0) < t.min) y1 = t.min;
        var w1 = (x1 - this.x0) >>> 0;
        var w2 = ((this.x0 + this.w0) - x1) >>> 0;
        var h1 = (y1 - this.y0) >>> 0;
        var h2 = ((this.y0 + this.h0) - y1) >>> 0;
        // overlap - calculate w,h first 
        /*
        var dw = w0 - t.min;
        var dh = h0 - t.min;
        var w1 = ((Math.random() * dw) + t.min) >>> 0;
        */
        r0.push(new rect(x0, y0, w1, h1)); 
        r0.push(new rect(x1, y0, w2, h1));
        r0.push(new rect(x0, y1, w1, h2));
        r0.push(new rect(x1, y1, w2, h2));
        return r0;
    }
}
// inv
var inv = function(n0, s0, m0, c0) {
    this.n0 = n0;
    this.s0 = s0;
    this.m0 = m0;
    this.c0 = c.comp();
}
// color
var c = {
    "comp": function() {
        var c0 = [];
        for (var i = 0; i < 4; i++) {
            c0.push(c.rb(255));
        }
        return c0;
    },
    "init": function() {
        c.rgba = []; // type'd // instanceof
        c.hsla = [];
        c.shuf();
    },
    "shuf": function() {
        for (var i = 0; i < 4; i++) {
            c.rgba[i] = c.rb(255);
        }
        c.hsla[0] = c.rb(255);
        c.hsla[1] = c.rb(100);
        c.hsla[2] = c.rb(100);
        c.hsla[3] = c.rb(255);
    },
    "rb": function(n0) {
        return ((Math.random() * n0) >>> 0);
    },
    "cssr": function() {
        var s0 = "rgba(";
        for (var i = 0; i < 3; i++) {
            s0 += c.rgba[i].toString();
            s0 += ",";
        }
        s0 += (c.rgba[3] / 255.0).toString();
        s0 += ")";
        return s0;
    },
    "cssh": function() {
        var s0 = "hsla(";
        s0 += c.hsla[0].toString();
        s0 += ",";
        for (var i = 1; i < 3; i++) {
            s0 += c.hsla[i];
            s0 += "%,";
        }
        s0 += (c.hsla[3] / 255.0).toString();
        s0 += ")";
        return s0;
    }
}
        </script>
    </head>
    <body id="alpha">
    </body>
</html>
<!--
    
    tree subdivison of rects
    stochastically, down to min size
    each node contains, x0, y0, w0, h0, c0, inv0
    inv = n0, a0, m0, c0
    render - translate to center of rect, rotate (news), restore

-->
